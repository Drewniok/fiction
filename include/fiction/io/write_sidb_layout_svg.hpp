//
// Created by sophia on 12/30/18.
//

#ifndef FICTION_WRITE_SVG_LAYOUT_HPP
#define FICTION_WRITE_SVG_LAYOUT_HPP

#include "fiction/layouts/bounding_box.hpp"
#include "fiction/layouts/coordinates.hpp"
#include "fiction/technology/sidb_charge_state.hpp"
#include "fiction/traits.hpp"
#include "utils/version_info.hpp"

#include <fmt/format.h>

#include <array>
#include <cmath>
#include <cstdint>
#include <exception>
#include <fstream>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>
#include <string_view>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

namespace fiction
{

/**
 * Parameters for writing SVG SiDB layouts.
 */
struct write_sidb_layout_svg_params
{
    /**
     * Limit details to create smaller file sizes.
     */
    bool simple = false;

    /**
     * Size of the lattice points in SVG units.
     */
    double lattice_point_size = 0.2;

    /**
     * Size of the SiDB dots in SVG units.
     */
    double sidb_dot_size = 0.8;

    /**
     * Scaling factor for the overall layout.
     */
    double scaling_factor = 10.0;

    /**
     * Border width for the SiDB dots.
     */
    double border_width = 0.2;
};

/**
 * Exception for unsupported cell types.
 */
template <typename Coordinate>
class unsupported_cell_type_exception : public std::exception
{
  public:
    explicit unsupported_cell_type_exception(const Coordinate& c) noexcept : coord{c} {}

    [[nodiscard]] Coordinate where() const noexcept
    {
        return coord;
    }

  private:
    Coordinate coord;
};

namespace detail
{

namespace svg
{

// Color definitions
inline constexpr const char* NEUTRAL_DOT_COLOR      = "#6e7175";
inline constexpr const char* HIGHLIGHT_BORDER_COLOR = "#e6e6e6";
inline constexpr const char* HIGHLIGHT_FILL_COLOR   = "#d0d0d0";
inline constexpr const char* NEGATIVE_COLOR         = "#00ADAE";
inline constexpr const char* POSITIVE_COLOR         = "#E34857";

// SVG Header with numbered placeholders
inline constexpr const char* HEADER = R"(<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Generated by {0} ({1}) -->

<svg
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:cc="http://creativecommons.org/ns#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns="http://www.w3.org/2000/svg"
    viewBox="{2} {3} {4} {5}"
    version="1.1">
    <metadata>
        <rdf:RDF>
            <cc:Work rdf:about="">
                <dc:format>image/svg+xml</dc:format>
                <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                <dc:title></dc:title>
            </cc:Work>
        </rdf:RDF>
    </metadata>
    {6} <!-- PATH_DEFINITION placeholder -->
    {7} <!-- Background rectangle placeholder -->
    <g>
        {8} <!-- SVG content placeholder -->
    </g>
</svg>)";

// IDs for reusable SVG elements
inline constexpr const char* PATH_ID = "lattice_point";
inline constexpr const char* SIDB_ID = "sidb_dot";

// SVG path definitions for lattice points and SiDB dots
// Updated to include placeholders for sizes
inline constexpr const char* PATH_DEFINITION = R"(
<defs>
    <!-- Small lattice point -->
    <circle id="lattice_point" cx="0" cy="0" r="{0}"/>
    <!-- Larger SiDB dot -->
    <circle id="sidb_dot" cx="0" cy="0" r="{1}"/>
</defs>
)";

}  // namespace svg

template <typename Lyt>
class write_sidb_layout_svg_impl
{
  public:
    /**
     * Constructor.
     */
    write_sidb_layout_svg_impl(const Lyt& layout, std::ostream& stream, const write_sidb_layout_svg_params& p = {}) :
            lyt{layout},
            os{stream},
            ps{p}
    {}

    /**
     * Runs the SVG generation process.
     */
    void run()
    {
        generate_svg();
    }

  private:
    Lyt                          lyt;
    std::ostream&                os;
    write_sidb_layout_svg_params ps;

    /**
     * Generates an SVG string representing the lattice points (small dots).
     */
    std::string generate_lattice_point(double x, double y, const std::string& fill_color)
    {
        return fmt::format(R"(<use xlink:href="#{0}" x="{1}" y="{2}" style="fill:{3};"/>)", svg::PATH_ID, x, y,
                           fill_color);
    }

    /**
     * Generates an SVG string representing larger SiDB dots.
     */
    std::string generate_sidb_dot(double x, double y, const std::string& fill_color, const std::string& border_color,
                                  double border_width, std::optional<sidb_charge_state> charge_state = std::nullopt)
    {
        std::string fill_color_charge   = fill_color;
        std::string border_color_charge = border_color;
        double      fill_opacity        = 1.0;

        if (charge_state.has_value())
        {
            switch (charge_state.value())
            {
                case (sidb_charge_state::POSITIVE):
                {
                    fill_color_charge   = svg::POSITIVE_COLOR;
                    border_color_charge = svg::POSITIVE_COLOR;
                    break;
                }
                case (sidb_charge_state::NEGATIVE):
                {
                    fill_color_charge   = svg::NEGATIVE_COLOR;
                    border_color_charge = svg::NEGATIVE_COLOR;
                    break;
                }
                case (sidb_charge_state::NEUTRAL):
                {
                    fill_color_charge   = svg::NEUTRAL_DOT_COLOR;
                    border_color_charge = svg::HIGHLIGHT_BORDER_COLOR;
                    fill_opacity        = 0.0;
                    break;
                }
                default:
                {
                    fill_color_charge   = svg::NEUTRAL_DOT_COLOR;
                    border_color_charge = svg::HIGHLIGHT_BORDER_COLOR;
                    break;
                }
            }
        }

        return fmt::format(
            R"(<use xlink:href="#{0}" x="{1}" y="{2}" style="fill:{3}; fill-opacity:{4}; stroke:{5}; stroke-width:{6};"/>)",
            svg::SIDB_ID, x, y, fill_color_charge, fill_opacity, border_color_charge, border_width);
    };

    /**
     * Generates the SVG layout with both lattice points and SiDB dots.
     */
    void generate_svg()
    {
        std::stringstream svg_content;

        // Prepare the formatted PATH_DEFINITION with the sizes
        const std::string formatted_path_definition =
            fmt::format(svg::PATH_DEFINITION, ps.lattice_point_size, ps.sidb_dot_size);

        // Compute the bounding box of the layout
        const auto bb  = bounding_box_2d{lyt};
        const auto min = bb.get_min();
        const auto max = bb.get_max();

        const double scaling_factor = ps.scaling_factor;

        // Generate all lattice points
        const auto all_coords = all_coordinates_in_spanned_area(min, max);
        for (const auto& coord : all_coords)
        {
            auto coord_shifted = coord;
            coord_shifted.x += 1;
            coord_shifted.y += 2;

            const auto nm_pos = sidb_nm_position(lyt, coord_shifted);

            svg_content << generate_lattice_point(nm_pos.first * scaling_factor, nm_pos.second * scaling_factor,
                                                  svg::NEUTRAL_DOT_COLOR);
        }

        // Generate SiDB dots
        lyt.foreach_cell(
            [this, &svg_content, scaling_factor](const auto& cell)
            {
                auto cell_shifted = cell;
                cell_shifted.x += 1;
                cell_shifted.y += 2;

                const auto nm_pos = sidb_nm_position(lyt, cell_shifted);

                if constexpr (is_charge_distribution_surface_v<Lyt>)
                {
                    // If the layout has charge distribution information
                    const auto charge_state = lyt.get_charge_state(cell);
                    svg_content << generate_sidb_dot(nm_pos.first * scaling_factor, nm_pos.second * scaling_factor,
                                                     svg::NEUTRAL_DOT_COLOR, svg::HIGHLIGHT_BORDER_COLOR,
                                                     ps.border_width, charge_state);
                }
                else
                {
                    // Default SiDB dot without charge state
                    svg_content << generate_sidb_dot(nm_pos.first * scaling_factor, nm_pos.second * scaling_factor,
                                                     svg::HIGHLIGHT_FILL_COLOR, svg::HIGHLIGHT_BORDER_COLOR,
                                                     ps.border_width);
                }
            });

        // Adjusted bounding box for viewBox calculation
        auto shifted_min = min;
        shifted_min.y += 1;
        auto shifted_max = max;
        shifted_max.x += 2;
        shifted_max.y += 3;

        // Compute viewBox dimensions
        const auto view_box_nm_min = sidb_nm_position(lyt, shifted_min);
        const auto view_box_nm_max = sidb_nm_position(lyt, shifted_max);

        const double viewbox_x      = view_box_nm_min.first * scaling_factor;
        const double viewbox_y      = view_box_nm_min.second * scaling_factor;
        const double viewbox_width  = (view_box_nm_max.first - view_box_nm_min.first) * scaling_factor;
        const double viewbox_height = (view_box_nm_max.second - view_box_nm_min.second) * scaling_factor;

        // Generate background rectangle
        const std::string background_rect =
            fmt::format(R"(<rect x="{0}" y="{1}" width="{2}" height="{3}" style="fill:{4};"/>)", viewbox_x, viewbox_y,
                        viewbox_width, viewbox_height, "#2d333b");

        // Generate the final SVG content
        os << fmt::format(svg::HEADER, FICTION_VERSION, FICTION_REPO, viewbox_x, viewbox_y, viewbox_width,
                          viewbox_height, formatted_path_definition, background_rect, svg_content.str());
    };
};

};  // namespace detail

/**
 * Writes an SVG representation of a cell-level SiDB layout into an output stream.
 *
 * @tparam Lyt Cell-level SiDB layout type.
 * @param lyt The layout to be written.
 * @param os The output stream to write into.
 * @param ps Parameters.
 */
template <typename Lyt>
void write_sidb_layout_svg(const Lyt& lyt, std::ostream& os, const write_sidb_layout_svg_params& ps = {})
{
    static_assert(is_cell_level_layout_v<Lyt>, "Lyt is not a cell-level layout");
    static_assert(has_sidb_technology_v<Lyt>, "Lyt must be a SiDB layout");
    static_assert(std::is_same_v<coordinate<Lyt>, offset::ucoord_t>, "Lyt must use unsigned Cartesian coordinates");

    detail::write_sidb_layout_svg_impl<Lyt> impl{lyt, os, ps};
    impl.run();
}

/**
 * Writes an SVG representation of a cell-level SiDB layout into a file.
 *
 * @tparam Lyt Cell-level SiDB layout type.
 * @param lyt The layout to be written.
 * @param filename The file name to create and write into.
 * @param ps Parameters.
 */
template <typename Lyt>
void write_sidb_layout_svg(const Lyt& lyt, const std::string_view& filename,
                           const write_sidb_layout_svg_params& ps = {})
{
    std::ofstream os{filename.data(), std::ofstream::out};

    if (!os.is_open())
    {
        throw std::ofstream::failure("Could not open file");
    }

    write_sidb_layout_svg(lyt, os, ps);
    os.close();
}

}  // namespace fiction

#endif  // FICTION_WRITE_SVG_LAYOUT_HPP

//
// Created by Jan Drewniok 05.11.24.
//

#ifndef FICTION_WRITE_SIDB_LAYOUT_SVG_HPP
#define FICTION_WRITE_SIDB_LAYOUT_SVG_HPP

#include "fiction/layouts/bounding_box.hpp"
#include "fiction/technology/sidb_charge_state.hpp"
#include "fiction/traits.hpp"
#include "utils/version_info.hpp"

#include <fmt/format.h>

#include <cstdint>
#include <fstream>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

namespace fiction
{

namespace svg
{
// Color definitions
inline constexpr const char* NEUTRAL_COLOR                   = "#6e7175";
inline constexpr const char* NEGATIVE_COLOR                  = "#00ADAE";
inline constexpr const char* POSITIVE_COLOR                  = "#E34857";
inline constexpr const char* BACKGROUND_COLOR_BRIGHT         = "#ffffff";
inline constexpr const char* BACKGROUND_COLOR_DARK           = "#25323D";
inline constexpr const char* SIDB_DOT_DARK_MODE              = "#C8C8C8";
inline constexpr const char* SIDB_DOT_BRIGHT_MODE            = "#ffffff";
inline constexpr const char* SIDB_DOT_LINE_COLOR_DARK_MODE   = "#ffffff";
inline constexpr const char* SIDB_DOT_LINE_COLOR_BRIGHT_MODE = "#C8C8C8";
inline constexpr const char* SI_LATTICE                      = "#6e7175";

// SVG Header with numbered placeholders
inline constexpr const char* HEADER_TEMPLATE = R"(<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Generated by {0} ({1}) -->
<svg
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:cc="http://creativecommons.org/ns#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns="http://www.w3.org/2000/svg"
    viewBox="{2} {3} {4} {5}"
    version="1.1">
    <metadata>
        <rdf:RDF>
            <cc:Work rdf:about="">
                <dc:format>image/svg+xml</dc:format>
                <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                <dc:title></dc:title>
            </cc:Work>
        </rdf:RDF>
    </metadata>
    {6} <!-- PATH_DEFINITION placeholder -->
    {7} <!-- Background rectangle placeholder -->
    <g>
        {8} <!-- SVG content placeholder -->
    </g>
</svg>)";

// SVG path definitions for lattice points and SiDBs
static constexpr const char* PATH_DEFINITION_TEMPLATE = R"(
<defs>
    <!-- lattice point -->
    <circle id="lattice_point" cx="0" cy="0" r="{0}"/>
    <!-- SiDB -->
    <circle id="sidb_color" cx="0" cy="0" r="{1}"/>
</defs>
)";

}  // namespace svg

/**
 * Enumeration to specify the color mode for the SVG output.
 */
enum class color_mode : uint8_t
{
    /**
     * Dark mode.
     */
    DARK,
    /**
     * Light mode.
     */
    LIGHT
};
/**
 * Parameters for writing SiDB layouts to SVG format.
 */
struct write_sidb_layout_svg_params
{
    /**
     * Size of the H-Si lattice points in SVG units.
     */
    double lattice_point_size = 0.3;
    /**
     * Size of the SiDB in SVG units.
     */
    double sidb_size = 0.9;
    /**
     * Border width of the SiDB.
     */
    double sidb_border_width = 0.3;
    /**
     * The color mode of the background for the SVG output.
     */
    color_mode color_background = color_mode::DARK;
};

namespace detail
{

template <typename Lyt>
class write_sidb_layout_svg_impl
{
  public:
    /**
     * Constructor.
     */
    write_sidb_layout_svg_impl(const Lyt& layout, std::ostream& stream, const write_sidb_layout_svg_params& p = {}) :
            lyt{layout},
            os{stream},
            ps{p}
    {
        set_colors();
    }

    /**
     * Runs the SVG generation process.
     */
    void run()
    {
        generate_svg();
    }

  private:
    /**
     * The SiDB layout to be written.
     */
    const Lyt& lyt;
    /**
     * The output stream to write into.
     */
    std::ostream& os;
    /**
     * Parameters for the SVG generation.
     */
    const write_sidb_layout_svg_params ps{};
    /**
     * The color mode for the SVG output.
     */
    std::string background_color;
    /**
     * The color of the SiDB without charge information.
     */
    std::string sidb_color;
    /**
     * The edge color of the SiDB without charge information.
     */
    std::string sidb_edge_color;
    /**
     * Sets the colors based on the color mode.
     */
    void set_colors() noexcept
    {
        if (ps.color_background == color_mode::LIGHT)
        {
            // fiction namespace is needed to avoid windows and linux conflict
            background_color = fiction::svg::BACKGROUND_COLOR_BRIGHT;
            sidb_color       = fiction::svg::SIDB_DOT_BRIGHT_MODE;
            sidb_edge_color  = fiction::svg::SIDB_DOT_LINE_COLOR_BRIGHT_MODE;
        }
        else
        {
            // fiction namespace is needed to avoid windows and linux conflict
            background_color = fiction::svg::BACKGROUND_COLOR_DARK;
            sidb_color       = fiction::svg::SIDB_DOT_DARK_MODE;
            sidb_edge_color  = fiction::svg::SIDB_DOT_LINE_COLOR_DARK_MODE;
        }
    }

    /**
     * Generates an SVG string representing an H-Si lattice point.
     *
     * @param x The x-coordinate of the lattice point.
     * @param y The y-coordinate of the lattice point.
     * @param fill_color The fill color of the lattice point.
     *
     * @return The SVG string representing the lattice point.
     */
    [[nodiscard]] std::string generate_lattice_point(const double x, const double y,
                                                     const std::string& fill_color) const noexcept
    {
        return fmt::format(R"(<use xlink:href="#lattice_point" x="{0}" y="{1}" style="fill:{2};"/>)", x, y, fill_color);
    }

    /**
     * Generates an SVG string representing an SiDB.
     *
     * @param x The x-coordinate of the SiDB.
     * @param y The y-coordinate of the SiDB.
     * @param charge_state The charge state of the SiDB.
     *
     * @return The SVG string representing the SiDB.
     */
    [[nodiscard]] std::string generate_sidb(const double x, const double y,
                                            const std::optional<sidb_charge_state>& charge_state = std::nullopt) const
    {
        std::string fill_color   = sidb_color;
        std::string border_color = sidb_edge_color;

        auto fill_opacity = 1.0;

        if (charge_state.has_value())
        {
            switch (charge_state.value())
            {
                case (sidb_charge_state::POSITIVE):
                {
                    fill_color   = fiction::svg::POSITIVE_COLOR;
                    border_color = fiction::svg::POSITIVE_COLOR;
                    break;
                }
                case (sidb_charge_state::NEGATIVE):
                {
                    fill_color   = fiction::svg::NEGATIVE_COLOR;
                    border_color = fiction::svg::NEGATIVE_COLOR;
                    break;
                }
                case (sidb_charge_state::NEUTRAL):
                {
                    fill_opacity = 0.0;
                    break;
                }
                default:
                {
                    border_color = fiction::svg::NEUTRAL_COLOR;
                    fill_opacity = 0.0;
                    break;
                }
            }
        }

        return fmt::format(
            R"(<use xlink:href="#sidb_color" x="{0}" y="{1}" style="fill:{2}; fill-opacity:{3}; stroke:{4}; stroke-width:{5};"/>)",
            x, y, fill_color, fill_opacity, border_color, ps.sidb_border_width);
    }

    /**
     * Generates the SVG layout with both H-Si lattice points and SiDBs.
     */
    void generate_svg() const
    {
        std::stringstream svg_content{};

        // Prepare the PATH_DEFINITION_TEMPLATE with the sizes
        const std::string path_definition_template =
            fmt::format(fiction::svg::PATH_DEFINITION_TEMPLATE, ps.lattice_point_size, ps.sidb_size);

        // Compute the bounding box of the layout
        const auto bb        = bounding_box_2d{lyt};
        const auto min_coord = bb.get_min();
        const auto max_coord = bb.get_max();

        // Generate all lattice points
        const auto all_coords = all_coordinates_in_spanned_area(min_coord, max_coord);

        for (const auto& coord : all_coords)
        {
            // Shift coordinates for alignment
            auto shifted_coord = coord;

            shifted_coord.x += 1;
            shifted_coord.y += 2;

            const auto nm_pos = sidb_nm_position(lyt, shifted_coord);

            svg_content << generate_lattice_point(nm_pos.first * 10, nm_pos.second * 10, fiction::svg::SI_LATTICE);
        }

        std::vector<cell<Lyt>> all_cells{};
        all_cells.reserve(lyt.num_cells());
        // collect all cells
        lyt.foreach_cell([&all_cells](const auto& cell) { all_cells.push_back(cell); });
        std::sort(all_cells.begin(), all_cells.end());

        for (const auto& cell : all_cells)
        {
            // Shift coordinates for alignment
            auto shifted_cell = cell;

            // shift for padding
            shifted_cell.x += 1;
            shifted_cell.y += 2;

            const auto nm_pos = sidb_nm_position(lyt, shifted_cell);

            if constexpr (is_charge_distribution_surface_v<Lyt>)
            {
                // If the layout has charge distribution information
                const auto charge_state = lyt.get_charge_state(cell);
                svg_content << generate_sidb(nm_pos.first * 10, nm_pos.second * 10, charge_state);
            }
            else
            {
                // Default SiDB dot without charge state
                svg_content << generate_sidb(nm_pos.first * 10, nm_pos.second * 10);
            }
        };

        auto shifted_max = max_coord;

        // shift for padding

        shifted_max.x += 2;
        shifted_max.y += 3;

        // Compute viewBox dimensions
        const auto view_box_nm_min = sidb_nm_position(lyt, min_coord);
        const auto view_box_nm_max = sidb_nm_position(lyt, shifted_max);

        const auto viewbox_x      = view_box_nm_min.first * 10;
        const auto viewbox_y      = view_box_nm_min.second * 10;
        const auto viewbox_width  = (view_box_nm_max.first - view_box_nm_min.first) * 10;
        const auto viewbox_height = (view_box_nm_max.second - view_box_nm_min.second) * 10;

        // Generate background rectangle
        const auto background_rect =
            fmt::format(R"(<rect x="{0}" y="{1}" width="{2}" height="{3}" style="fill:{4};"/>)", viewbox_x, viewbox_y,
                        viewbox_width, viewbox_height, background_color);

        // Generate the final SVG content
        os << fmt::format(fiction::svg::HEADER_TEMPLATE, FICTION_VERSION, FICTION_REPO, viewbox_x, viewbox_y,
                          viewbox_width, viewbox_height, path_definition_template, background_rect, svg_content.str());
    }
};

}  // namespace detail

/**
 * Writes an SVG representation of an SiDB cell-level SiDB layout into an output stream.
 *
 * @note SiDB defects are not supported yet.
 *
 * @tparam Lyt SiDB cell-level layout type.
 * @param lyt The layout to be written.
 * @param os The output stream to write into.
 * @param ps Parameters.
 */
template <typename Lyt>
void write_sidb_layout_svg(const Lyt& lyt, std::ostream& os, const write_sidb_layout_svg_params& ps = {})
{
    static_assert(is_cell_level_layout_v<Lyt>, "Lyt is not a cell-level layout");
    static_assert(has_sidb_technology_v<Lyt>, "Lyt must be a SiDB layout");
    static_assert(!is_sidb_defect_surface_v<Lyt>, "SiDB defects are not supported");

    detail::write_sidb_layout_svg_impl<Lyt> p{lyt, os, ps};
    p.run();
}

/**
 * Writes an SVG representation of an SiDB cell-level SiDB layout into a file.
 *
 * @note SiDB defects are not supported yet.
 *
 * @tparam Lyt SiDB cell-level layout type.
 * @param lyt The layout to be written.
 * @param filename The file name to create and write into.
 * @param ps Parameters.
 */
template <typename Lyt>
void write_sidb_layout_svg(const Lyt& lyt, const std::string_view& filename,
                           const write_sidb_layout_svg_params& ps = {})
{
    static_assert(is_cell_level_layout_v<Lyt>, "Lyt is not a cell-level layout");
    static_assert(has_sidb_technology_v<Lyt>, "Lyt must be a SiDB layout");
    static_assert(!is_sidb_defect_surface_v<Lyt>, "SiDB defects are not supported");

    std::ofstream os{filename.data(), std::ofstream::out};

    if (!os.is_open())
    {
        throw std::ofstream::failure("Could not open file");
    }

    write_sidb_layout_svg(lyt, os, ps);
    os.close();
}

}  // namespace fiction

#endif  // FICTION_WRITE_SIDB_LAYOUT_SVG_HPP
